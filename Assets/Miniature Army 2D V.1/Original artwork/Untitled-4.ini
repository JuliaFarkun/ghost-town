import numpy as np

def simple_system(frames):
    '''Найти систему Az=b с 50*20 переменными, депикселизующую скрытую область'''
    variableNum = 50 * 20
    equationNum = 51 * 1100
    A = np.zeros(shape=[equationNum, variableNum])
    b = np.zeros(shape=[equationNum])

    for frame_num in range(len(frames)):
        shift_y = frame_num // 10
        base_idx = frame_num * 1100
        
        # Обработка каждого столбца в текущем кадре
        for y_pos in range(shift_y, shift_y + 20):
            # Обработка каждой строки для данного столбца
            for x_pos in range(frame_num, frame_num + 50):
                # Вычисляем индексы для матрицы A
                matrix_x = x_pos - frame_num
                matrix_y = y_pos - shift_y
                pixel_idx = matrix_x * 20 + matrix_y
                
                # Проверяем, находится ли точка в скрытой области
                if 20 <= x_pos < 80:
                    # Вычисляем индексы для скрытой области
                    block_idx = base_idx + 1000 + 5 * ((x_pos - 20) // 5) + y_pos // 5
                    A[block_idx][pixel_idx] = 1
                    b[block_idx] = frames[frame_num][x_pos, y_pos] * 25
                else:
                    # Вычисляем индексы для видимой области
                    visible_idx = base_idx + matrix_x * 20 + matrix_y
                    A[visible_idx][pixel_idx] = 1
                    b[visible_idx] = frames[frame_num][x_pos, y_pos]

    return [A, b]

def is_consistent_system(A, b):
    '''Вернуть True тогда и только тогда, когда система Az=b имеет решение'''
    if A.size == 0 or b.size == 0:
        return True
        
    # Проверяем согласованность размерностей
    if len(b) != A.shape[0]:
        return False
        
    # Формируем расширенную матрицу системы
    extended_matrix = np.concatenate([A, b.reshape(-1, 1)], axis=1)
    
    # Используем теорему о ранге расширенной матрицы
    eps = 1e-10  # Порог для численной устойчивости
    rank_orig = np.linalg.matrix_rank(A, tol=eps)
    rank_extended = np.linalg.matrix_rank(extended_matrix, tol=eps)
    
    # Система совместна тогда и только тогда, когда
    # ранг исходной матрицы равен рангу расширенной
    return rank_orig == rank_extended

def depixelate_region50x20(A, b):
    '''Приближённо решить систему Az=b и вернуть соответствующее изображение
    
    Параметры:
    A : numpy.ndarray - матрица коэффициентов системы уравнений
    b : numpy.ndarray - вектор правой части системы уравнений
    
    Возвращает:
    numpy.ndarray - матрица 50x20 с восстановленными значениями пикселей
    '''
    output_matrix = np.zeros((50, 20), dtype=int)
    row_size = 20

    # Решение через нормальные уравнения (A^T A)z = A^T b
    AtA = A.T @ A
    Atb = A.T @ b
    if np.linalg.matrix_rank(AtA) == AtA.shape[0]:
        z = np.linalg.solve(AtA, Atb)
    else:
        z = np.zeros(50 * 20)

    for pixel_index in range(1000):
        current_value = z[pixel_index]
        bounded_value = int(round(max(0, min(255, current_value))))
        row_idx = pixel_index // row_size
        col_idx = pixel_index % row_size
        output_matrix[row_idx, col_idx] = bounded_value

    return output_matrix

def predictor_coefficients(students_data):
    '''
    Определяет оптимальные коэффициенты линейной регрессии для предсказания итоговой оценки f_i
    по известным данным о студенте: a_i, b_i, c_i, d_i.
    Возвращает массив из пяти коэффициентов [w1, w2, w3, w4, w5].
    '''
    features = []
    targets = []
    for record in students_data:
        a, b, c, d, f = record
        features.append([a, b, c, d, 1])
        targets.append(f)
    X = np.array(features)
    y = np.array(targets)

    XtX = X.T @ X
    Xty = X.T @ y
    if np.linalg.matrix_rank(XtX) == XtX.shape[0]:
        w = np.linalg.solve(XtX, Xty)
    else:
        w = np.zeros(5)
    return w

def cubic_approximation(points):
    '''
    По набору точек (x_i, y_i, t_i) находит коэффициенты двух кубических многочленов,
    аппроксимирующих траекторию: x(t) и y(t).
    Возвращает два массива коэффициентов: [a_x, b_x, c_x, d_x], [a_y, b_y, c_y, d_y].
    '''
    t_list = []
    x_list = []
    y_list = []
    for x, y, t in points:
        t_list.append(t)
        x_list.append(x)
        y_list.append(y)

    # Формируем матрицу признаков для кубического полинома
    T = np.array([[t**3, t**2, t, 1] for t in t_list])
    X = np.array(x_list)
    Y = np.array(y_list)

    # Составляем нормальные уравнения
    TT = T.T @ T
    TX = T.T @ X
    TY = T.T @ Y

    # Проверяем, можно ли решить систему (TT невырождена)
    if np.linalg.matrix_rank(TT) == TT.shape[0]:
        coeffs_x = np.linalg.solve(TT, TX)
        coeffs_y = np.linalg.solve(TT, TY)
    else:
        # Если система вырождена, возвращаем нули (или можно придумать другое поведение)
        coeffs_x = np.zeros(4)
        coeffs_y = np.zeros(4)

    return [coeffs_x, coeffs_y]